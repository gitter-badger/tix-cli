#!/bin/bash
#
# Gets the current status of the module (git)

set -e


OPTIND=1

latest=false
module_name=""
branch_name="master"
revision_count=10

options=":lm:b:c:"

### Command line flags
while getopts "$options" opt ; do
    case "$opt" in
    l ) # Gets latest annotated revision
      latest=true
      ;;
    m ) # Name of module to get revisions
      module_name=$OPTARG
      ;;
    b ) # Gets revisions for specific branch, optional
      branch_name=$OPTARG
      ;;
    c ) # Specifies the number of latest revisions to show for both tags and commits, optional
      revision_count=$OPTARG
      ;;
    \?)
      >&2 echo "Unknown option: -$OPTARG" && exit 1
      ;;
    : )
      >&2 echo "Missing option argument for -$OPTARG" && exit 1
      ;;
    * )
      >&2 echo "Unimplemented option: -$OPTARG" && exit 1
    esac
done

. $HOME/.tixrc

### if no arguments, throw an error
if [ "$module_name" = "" ]; then
  >&2 echo -e "${RED}--Must specify a module name (-m) to check revisions for--${NC}" && exit 1
fi

module_root="$MODULE_ROOT/$module_name"
remote_branch="origin/$branch_name"

### if module not cloned, clone it
if [ ! -d "$module_root" ]; then
  >&2 echo -e "${CYAN}Module $module_name does not exist at $module_root, cloning...${NC}"
  >&2 clone-module $module_name
fi

pushd "$module_root" >/dev/null
  git fetch >/dev/null
  git fetch --tags >/dev/null

  # If latest is specified, just return latest annotated version
  if [ "$latest" = true ] ; then
    git describe --abbrev=0 --tags
    exit 0
  fi

  >&2 echo -e "${YELLOW}--tags--${NC}"
  git tag -l | sort -r -n -t. -k1,1 -k2,2 -k3,3 | head -n $revision_count
  >&2 echo -e "${YELLOW}--recent commit hashes--${NC}"
  git log "$remote_branch" --abbrev-commit --pretty=oneline --max-count=$revision_count
popd >/dev/null