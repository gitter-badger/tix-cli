#!/bin/bash
#
# Gets the current status of the module (git)

set -e

latest=false
module_name=""
branch_name="master"
revision_count=10

usage_short="${CYAN}Usage: revisions [-l] [-b branch-name] [-c revision-count] module-name${NC}"
usage_long="$usage_short\n-l: Gets the latest annotated revision."
usage_long="$usage_long\n-b: Name of branch to get revisions for (default master)."
usage_long="$usage_long\n-c: Specifies the number of recent revisions to get for tags and commits (default 10)."

usage_short="$usage_short\nUse -h to get supported command information."

options=":lb:c:h"
OPTIND=1
while getopts "$options" opt ; do
    case "$opt" in
    l ) # Gets latest annotated revision
      latest=true
      ;;
    m ) # Name of module to get revisions
      module_name=$OPTARG
      ;;
    b ) # Gets revisions for specific branch, optional
      branch_name=$OPTARG
      ;;
    c ) # Specifies the number of latest revisions to show for both tags and commits, optional
      revision_count=$OPTARG
      ;;
    h )
      >&2 echo -e "$usage_long" && exit 1
      exit 0
      ;;
    \?)
      >&2 echo -e "Unknown option: -$OPTARG"
      >&2 echo -e "$usage_short"
      exit 1
      ;;
    : )
      >&2 echo -e "Missing option argument for -$OPTARG"
      >&2 echo -e "$usage_short"
      exit 1
      ;;
    * )
      >&2 echo -e "Unimplemented option: -$OPTARG" && exit 1
      >&2 echo -e "$usage_short"
      exit 1
    esac
done
shift $((OPTIND-1))

module_name=$1

. "$HOME/.tixrc"

### if no arguments, throw an error
if [ "$module_name" = "" ]; then
  >&2 echo -e "$usage_short" && exit 1
fi

module_root="$BUILD_ROOT/$module_name"
remote_branch="origin/$branch_name"

### if module not cloned, clone it
if [ ! -d "$module_root" ]; then
  >&2 echo -e "${CYAN}Module $module_name does not exist at $module_root, cloning...${NC}"
  clone-module -b $module_name >/dev/null
fi

pushd "$module_root" >/dev/null
  git fetch &>/dev/null
  git fetch --tags &>/dev/null
  git checkout -q --force origin/master &>/dev/null

  # If latest is specified, just return latest annotated version
  if [ "$latest" = true ] ; then
    git describe --abbrev=0
    exit 0
  fi

  >&2 echo -e "${YELLOW}--tags--${NC}"
  git tag -l | sort -r -n -t. -k1,1 -k2,2 -k3,3 | head -n $revision_count
  >&2 echo -e "${YELLOW}--recent commit hashes--${NC}"
  git log "$remote_branch" --abbrev-commit --pretty=oneline --max-count=$revision_count
popd >/dev/null